#!r6rs
;; Copyright 2013 Derick Eddington.  My MIT-style license is in the file named
;; LICENSE from the original collection this file is distributed with.

(import
  (rnrs)
  (logji base)
  (srfi :78 lightweight-testing))


;;;; Variable and Constant Symbols

(let-syntax ((yes (syntax-rules () ((_ x) (check (variable? 'x) => #T))))
             (no (syntax-rules () ((_ x) (check (variable? 'x) => #F)))))
  (no ⊤)
  (no ⊥)
  (yes a)
  (parameterize-append ((constants '(a)))
    (no a)
    (yes b)
    (no ⊤)
    (no ⊥))
  (yes a))


;;;; Instances of Expressions

(define (vars-equal? a b)
  (define (sort-vars v)
    (list-sort (lambda ab (apply string<? (map symbol->string (map car ab))))
               v))
  (equal? (sort-vars a) (sort-vars b)))

(letrec-syntax ((yes (syntax-rules ()
                       ((_ pat expr => (var val) ...)
                        (check (instance? 'expr 'pat)
                               (=> vars-equal?)
                               '((var . val) ...)))
                       ((_ p e)
                        (yes p e =>))))
                (no (syntax-rules ()
                      ((_ pat expr)
                       (check (instance? 'expr 'pat) => #F)))))

  (yes v a
       => (v a))
  (yes v (o a)
       => (v (o a)))
  (yes v (oa (ob a) (oc b))
       => (v (oa (ob a) (oc b))))
  (yes v (o)
       => (v (o)))
  (yes v (oa (ob) (oc a b c))
       => (v (oa (ob) (oc a b c))))
  (yes v ⊤
       => (v ⊤))
  (yes v ⊥
       => (v ⊥))
  (yes ⊤ ⊤)
  (yes ⊥ ⊥)

  (no ⊤ ⊥)
  (no ⊤ a)
  (no ⊤ (o a))
  (no ⊥ ⊤)
  (no ⊥ a)
  (no ⊥ (o a))
  (parameterize-append ((constants '(v)))
    (no v a)
    (no v (o a))
    (no v ⊤)
    (no v ⊥)
    (yes v v))

  (no (o) a)
  (no (o v) a)
  (no (o) (a))
  (no (o v) (a b))
  (no (o v1 v2) (a b c))
  (no (o v1 v2 v3) (a b c d))
  (no (o v) (o))
  (no (o v1 v2) (o a))
  (no (o v1 v2) (o))
  (no (o v1 v2 v3) (o a b))
  (no (o v1 v2 v3) (o a))
  (no (o v1 v2 v3) (o))
  (no (o) (o a))
  (no (o) (o a b))
  (no (o) (o a b c))
  (no (o v) (o a b))
  (no (o v) (o a b c))
  (no (o v) (o a b c d))
  (no (o v1 v2) (o a b c))
  (no (o v1 v2) (o a b c d))
  (no (o v1 v2) (o a b c d e))
  (no (o v1 v2 v3) (o a b c d))
  (no (o v1 v2 v3) (o a b c d e))
  (no (o v1 v2 v3) (o a b c d e f))

  (yes o a
       => (o a))
  (yes o (o a)
       => (o (o a)))

  (yes (o) (o))
  (yes (o v) (o a)
       => (v a))
  (yes (o v) (o (o a))
       => (v (o a)))
  (yes (o v1 v2) (o a b)
       => (v1 a) (v2 b))
  (yes (o v1 v2) (o (z a) (w b))
       => (v1 (z a)) (v2 (w b)))
  (yes (o v1 v2 v3) (o a b c)
       => (v1 a) (v2 b) (v3 c))
  (yes (o v1 v2 v3) (o (x a) (y b) (z c))
       => (v1 (x a)) (v2 (y b)) (v3 (z c)))
  (yes (o v) (o (oa (ob) (oc a b c)))
       => (v (oa (ob) (oc a b c))))

  (no (o ⊤) (o ⊥))
  (no (o ⊤ ⊤) (o ⊤ ⊥))
  (no (o ⊤ ⊤) (o ⊥ ⊤))
  (no (o ⊤ ⊤) (o ⊥ ⊥))
  (no (o ⊤ ⊤ ⊤) (o ⊤ ⊤ ⊥))
  (no (o ⊤ ⊤ ⊤) (o ⊤ ⊥ ⊤))
  (no (o ⊤ ⊤ ⊤) (o ⊥ ⊤ ⊤))
  (no (o ⊤ ⊤ ⊤) (o ⊥ ⊥ ⊥))
  (no (o ⊤) (o a))
  (no (o ⊤) (o (o a)))
  (no (o ⊥) (o ⊤))
  (no (o ⊥) (o a))
  (no (o ⊥) (o (o a)))
  (parameterize-append ((constants '(v)))
    (no (o v) (o a))
    (no (o v) (o (o a)))
    (no (o v) (o ⊤))
    (no (o v) (o ⊥))
    (yes (o v) (o v)))

  (no (o v v) (o a b))
  (no (o v v) (o (x a) (x b)))
  (no (o v v) (o (x a b) (x a c)))
  (no (o v v) (o (x (a (b))) (x (a (c)))))
  (no (o (x v) (x v)) (o (x a) (x b)))
  (no (o (x v) (x v)) (o (x (x (a (b)))) (x (x (a (c))))))

  (yes (o v v) (o a a)
       => (v a))
  (yes (o v v) (o (x a) (x a))
       => (v (x a)))
  (yes (o v v) (o (x a b) (x a b))
       => (v (x a b)))
  (yes (o v v) (o (x a b c) (x a b c))
       => (v (x a b c)))
  (yes (o v v) (o (x (a (b))) (x (a (b))))
       => (v (x (a (b)))))
  (yes (o (x v) (x v))
       (o (x a) (x a))
       => (v a))
  (yes (o (x v) (z (x (o v))))
       (o (x a) (z (x (o a))))
       => (v a))

  (yes (o v1 v2) (o a a)
       => (v1 a) (v2 a))

  (yes (o v1 v2 v1 v2) (o a b a b)
       => (v1 a) (v2 b))
  (yes (o v1 v2 v1 v2 v1 v2) (o a b a b a b)
       => (v1 a) (v2 b))
  (yes (o v1 v2 v3 v3 v2 v1) (o a b c c b a)
       => (v1 a) (v2 b) (v3 c))
  (yes (o (x (o v1))
          v2
          (y v3 v1)
          (z (o (o v1) v2) v3))
       (o (x (o (a aa)))
          (b bb bbb)
          (y (c cc ccc cccc) (a aa))
          (z (o (o (a aa)) (b bb bbb)) (c cc ccc cccc)))
       => (v1 (a aa))
          (v2 (b bb bbb))
          (v3 (c cc ccc cccc)))
  (no (o (x (o v1))
          v2
          (y v3 v1)
          (z (o (o v1) v2) v3))
       (o (x (o (a aa)))
          (b bb bbb)
          (y (c cc ccc cccc) (a aa))
          (z (o (o (a aa)) (b bb bbb)) (c cc ccc ccc))))

  (no (∨ ⊤ x) (∨ x ⊤))
  (no (∨ x ⊤) (∨ ⊤ x))

  )

(let-syntax ((yes (syntax-rules ()
                    ((_ (pats ...) expr => match)
                     (check (instance-of-any? 'expr '(pats ...))
                            => 'match))))
             (no (syntax-rules ()
                   ((_ (pats ...) expr)
                    (check (instance-of-any? 'expr '(pats ...))
                           => #F)))))
  (yes (v) a => v)
  (yes (v1 v2) a => v1)
  (yes (v (o v)) (o a) => v)
  (yes ((o v) v) (o a) => (o v))

  (no ((a b) (c d)) (b e))
  (no ((a b) (c d)) (d e))
  (no ((a ⊤) (c ⊥)) (a e))
  (no ((a ⊤) (c ⊥)) (c e))

  (yes ((c v) (c v1 v2) (c)) (c) => (c))
  (yes ((c v) (c v1 v2) (c)) (c a a) => (c v1 v2))

  )

(let-syntax ((test (syntax-rules (=>)
                     ((_ spec => perms ...)
                      (check (permute 'spec) => '(perms ...))))))
  (test () =>)
  (test ((a)) => (a))
  (test ((a) (b)) => (a b))
  (test ((a) (b) (c)) => (a b c))
  (test ((a b)) => (a) (b))
  (test ((a b c)) => (a) (b) (c))
  (test ((a) (b c)) => (a b) (a c))
  (test ((a b) (c)) => (a c) (b c))
  (test ((a) (b c d)) => (a b) (a c) (a d))
  (test ((a b c) (d)) => (a d) (b d) (c d))
  (test ((a b) (c d)) => (a c) (a d) (b c) (b d))
  (test ((a b) (c d e)) => (a c) (a d) (a e) (b c) (b d) (b e))
  (test ((a b c) (d e)) => (a d) (a e) (b d) (b e) (c d) (c e))
  (test ((a) (b) (c d)) => (a b c) (a b d))
  (test ((a) (b c) (d)) => (a b d) (a c d))
  (test ((a b) (c) (d)) => (a c d) (b c d))
  (test ((a b) (c d) (e f)) => (a c e) (a c f) (a d e) (a d f)
                               (b c e) (b c f) (b d e) (b d f))
  (test ((a b c d) (e f g) (h i)) => (a e h) (a e i)
                                     (a f h) (a f i)
                                     (a g h) (a g i)
                                     (b e h) (b e i)
                                     (b f h) (b f i)
                                     (b g h) (b g i)
                                     (c e h) (c e i)
                                     (c f h) (c f i)
                                     (c g h) (c g i)
                                     (d e h) (d e i)
                                     (d f h) (d f i)
                                     (d g h) (d g i))
  )


(check-report)
