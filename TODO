Explore using instance? instead of term-equal? for finding bound terms in
environment look-ups.  If possible, this allows smoother use of laws, e.g.
($type (∧ x y)) can be evaluated by matching a bound law/pattern term like
($let (('($type a) boolean)
       ('($type b) boolean))
  ($let (('($type (∧ a b)) boolean))
    ))

Before above, commit all the work I did based on term-equal? even though it's
incomplete and not very tested.



Think about issue of: terms can be term-equal? with unbound symbols even if the
symbols have different other terms associated with them in their different
environments.  Right?  E.g.:

(term-equal? ($let (('($type a) foo))
               '(o a))
             ($let (('($type a) bar))
               '(o a)))
=> #T

Maybe this is justification for not supporting unbound symbols in term-equal?
So, instance? law-pattern terms would instead have to use some special value
type to identify variables and their domain types.

But even for bound symbols the problem remains, right?  E.g.:

($let ((a ...))
  (term-equal? ($let (('($type a) foo))
                 '(o a))
               ($let (('($type a) bar))
                 '(o a))))
=> #T

What if o depends on what ($type a) is bound to in the dynamic environment.  It
could affect the return value of o, in which case the terms aren't really equal!

This really brings into question whether term-equal? should be part of the
fundamental evaluation semantics.

By disallowing unbound symbols, the issue improves.  E.g.:

(term-equal? ($let ((a (type foo)))
               '(o a))
             ($let ((a (type bar)))
               '(o a)))
=> #F

But the issue will always remain because combiners have access to the dynamic
environments of their uses, and so can depend on anything bound in those envs
regardless of the operands' boundness.



I don't like that having special value type to identify law-pattern variables
creates a special-cased type that has fundamental different semantics.  Could
this make it difficult if some meta thing ever wants to deal with this special
type as just a value and not have it specially interpreted?

